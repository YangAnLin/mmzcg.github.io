---
title: Redis持久化
date: 2020-08-14 00:00:00
categories: Redis
---

![](https://raw.githubusercontent.com/YangAnLin/images/master/20200826194807.jpeg)

很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。
<!-- more --> 
Redis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。

Redis的一种持久化方式叫快照（snapshotting，RDB）

另一种方式是只追加文件（append-only file,AOF）

这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。

![image-20200813080458881](https://raw.githubusercontent.com/YangAnLin/images/master/20200826194817.png)

## RDB(快照)

save 会生成rdb文件

### RDB启动方式——save指令相关配置

- dbfilename dump.rdb
  说明：设置本地数据库文件名，默认值为dump.rdb
  经验：通常设置为dump-端口号.rdb,就是配置文件里配置的地址
- dir
  说明：设置存储.rdb文件的路径
  经验：通常设置成存储空间较大的目录中，目录名称data
- rdbcompression yes
  说明：设置存储至本地数据库时是否压缩数据，默认为yes，采用LZF压缩
  经验：通常默认为开启状态，如果设置成no，可以节省CPU运行时间，但会使存储的文件变大（巨大）
- rdbchecksumy yes
  说明：设置是否进行RDB文件格式的校验，该校验过程在写文件和读文件过程均进行
  经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险

注意：**Redis是单线程的**，所有命令都会在类似队列中排好队，不建议使用save指令，因为save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成位置，有可能会造成长时间阻塞，**线上环境不建议使用**

### RDB启动方式——bgsave指令

手动启动后台保存操作，但不是立即执行

![在这里插入图片描述](https://raw.githubusercontent.com/YangAnLin/images/master/20200826194834.png)

执行成功了不会在控制台输出,可以在日志中看到

```shell
58142:M 07 Aug 2020 07:23:17.355 * Starting BGSAVE for SYNC with target: disk
58142:M 07 Aug 2020 07:23:17.355 * Background saving started by pid 58183
58183:C 07 Aug 2020 07:23:17.357 * DB saved on disk
58183:C 07 Aug 2020 07:23:17.357 * RDB: 0 MB of memory used by copy-on-write
58142:M 07 Aug 2020 07:23:17.456 * Background saving terminated with success
```

bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用

### RDB启动方式——save配置

```shell
save second changes

second：监控时间范围
changes：监控key的变化量
```

```shell
save 900 1      #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
save 300 10     #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
save 60 10000    #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
```

### RDB启动方式——save配置原理

![在这里插入图片描述](https://raw.githubusercontent.com/YangAnLin/images/master/20200826194922.png)

**注意：**
save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的
save配置中对second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系
save配置启动后执行的是bgsave操作

### RDB启动方式——对比

![在这里插入图片描述](https://raw.githubusercontent.com/YangAnLin/images/master/20200826194906.png)

### RDB启动方式——其它启动方式

- 全量复制
  在主从复制中会提到
- 服务器运行过程中重启
  debug reload
- 关闭服务器时指定保存数据
  shutdown save

### RDB 优缺点

##### RDB优点

- RDB是一个紧凑压缩的二进制文件，存储效率较高
- RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景
- RDB恢复数据的速度要比AOF快很多
- 应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程己气中，用于灾难恢复

##### RDB缺点

- RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具体较大的可能性丢失数据
- bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能
- Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现个版本服务之间数据格式无法兼容现象

##### RDB存储的弊端

- 存储数据量较大，效率较低——基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低
- 大数据量下的IO性能较低
- 基于fork创建子进程，内存产生额外消耗
- 宕机带来的数据丢失风险

##### 解决思路

- 不写全数据，仅记录部分数据
- 改记录数据未记录操作过程
- 对所有操作均进行记录，排除丢失数据的风险
- 这也就是AOF的引入

## AOF

##### AOF写数据过程

![在这里插入图片描述](https://raw.githubusercontent.com/YangAnLin/images/master/20200826194940.png)

##### AOF写数据的三种策略

```shell
appendfsync always  #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec #每秒钟同步一次，显示地将多个写命令同步到硬盘 **(默认的)**
appendfsync no    #让操作系统决定何时进行同步
```

##### AOF功能开启和相关配置

```shell
# 是否开启APF持久化功能，默认为不开启
appendonly yes|no

# AOF写数据策略
appendfsync always|everysec|no

# AOF持久化文件名，默认文件名为appendonly.aof,建议配置为appendonly-端口号.aof
appendfilename filename

# AOF持久化文件保存路径，与RDB持久化文件保持一致即可
dir
```

##### 重写

随着命令的不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积，AOF文件重写是将Redis进程内的数据转换为写命令同步到新AOF文件的过程，简单说就是将同样一个数据的若干个命令执行结果转换为最终结果数据对应的指令进行记录

###### AOF重写作用

- 降低磁盘占用量，提高磁盘利用路
- 提高持久化效率，降低持久化写时间，提高IO性能
- 降低数据恢复用时，提高数据恢复效率

###### AOF重写规则

- 进程内已超时的数据不再写入文件
- 忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令　
  如del key1,hdel key2,srem key3,set key 222等
- 对统一数据的多条命令合并为一条命令
  如 lpush list1 a ,lpush list1 b,lpush list1 c可以转化为lpush list1 a b c
  为防止数据量过大造成客户端缓冲区溢出，对list,set,hash,set等类型，每条指令最多写入64个元素

###### 重写方式

```shell

# 手动重写,在命令行执行,会覆盖原来的aof文件,但是文件更小
bgrewriteaof

# 自动重写
auto-aof-rewrite-min-size 		size
auto-aof-rewrite-percentage 	percentage
```

手动重写流程:

![在这里插入图片描述](https://raw.githubusercontent.com/YangAnLin/images/master/20200826194958.png)

自动重写的触发条件:

```shell
# 自动重写触发条件设置
auto-aof-rewrite-min-size
auto-aof-rewrite-percentage percent

# 自动重写触发对比参数（运行指令info Persistence获取具体信息）
aof_current_size
aof_base_size
```

![在这里插入图片描述](https://raw.githubusercontent.com/YangAnLin/images/master/20200826195008.png)

![在这里插入图片描述](https://raw.githubusercontent.com/YangAnLin/images/master/20200826195016.png)

![在这里插入图片描述](https://raw.githubusercontent.com/YangAnLin/images/master/20200826195024.png)

## AOF和RDB的区别

![在这里插入图片描述](https://raw.githubusercontent.com/YangAnLin/images/master/20200826195031.png)

##### RDB和AOF的选择之感

- 对数据非常敏感，建议使用默认的AOF持久化方案
  AOF持久化策略使用erverysecond，每秒钟fsync一次。该策略redis任然可以保持很好的处理性能，当出现问题时，最多丢失0-1秒中的数据。
  注意：由于AOF文件存储体积较大，且恢复数据较慢
- 数据呈现阶段有效性，建议使用RDB持久化方案
  数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人工手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案
  注意：利用RDB实现紧凑的数据持久化会使Redis降得很低
- 综合对比

1. RDB与AOF得选择实际上是在做一种权衡，每种都有利弊
2. 如不能承受数分钟以内得数据丢失，对业务数据非常敏感，选用AOF
3. 如能承受数分钟以内数据丢失，且追求大数据集得恢复速度，选用RDB
   灾难恢复选用RDB
4. 双保险策略，同时开启RDB和AOF，重启后，Redis优先使用AOF来恢复数据，降低丢失数据的量

## **Redis 4.0 对于持久化机制的优化**

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。

如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。