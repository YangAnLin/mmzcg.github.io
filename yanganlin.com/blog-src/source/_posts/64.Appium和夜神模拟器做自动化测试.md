
---
title: Appium和夜神模拟器做自动化测试
date: 2020-07-26 20:16:00
categories: 
- 杂事
---

## 流程

1.安装JAVA_HOME

2.安装ANDROID_HOME

3.安装夜神模拟器和安装appium和node.js

4.调试环境

4.编写python脚本

## 1.安装JAVA_HOME环境

这个很重要,特别是我经常用IDEA做开发,平常就很少配置JAVA_HOME环境变量,,变量名为:`ANDROID_HOME`

## 2.安装ANDROID_HOME环境

看网上的教程,都是去官网下了个安卓的SDK,我一上官网,就只是提示我下载Android Studio,所以就安装了这个软件,在软件的配置里面找到的安卓的SDK的目录,然后就配置了环境变量

变量名为:`ANDROID_HOME`

变量值为:`C:\..\..\Android\Sdk`

然后在`Path`里添加:

`%ANDROID_HOME%\tools`

`%ANDROID_HOME%\platform-tools`

## 3.安装夜神模拟器和appium

夜神模拟器就下载最新版本的就可以

appium也直接在网上下载安装好就行

## 4.调试环境

1.把`C:\Program Files (x86)\Nox\bin`添加到Path环境变量红

2.查看夜神模拟器的adb版本号:`nox_adb.exe version`

```shell
y9507@DESKTOP-IAE2VRK  C:\Program Files (x86)\Nox\bin
❯ .\nox_adb.exe version
Android Debug Bridge version 1.0.41
Version 30.0.3-6597393
Installed as C:\Program Files (x86)\Nox\bin\nox_adb.exe
```

2查看adb版本号:`adb version`,这是安卓的sdk版本号

```shell
❯ adb version
Android Debug Bridge version 1.0.41
Version 30.0.3-6597393
Installed as C:\Users\xxxx\AppData\Local\Android\Sdk\platform-tools\adb.exe
```

如果他们不一样,就把安卓的adb.exe拷贝到``C:\Program Files (x86)\Nox\bin`里,并改名`nox_adb.exe`,再看看版本号是不是就一样的了

3.夜神模拟器连接上安卓sdk

```shell
❯ ./nox_adb.exe connect 127.0.0.1:62001
already connected to 127.0.0.1:62001
```

4.启动appium,现在先使用默认的设置,点击启动服务器

appium是基于node.js开发的,前提要安装好node.js

```shell
[Appium] Welcome to Appium v1.17.1
[Appium] Non-default server args:
[Appium]   allowInsecure: {
[Appium]   }
[Appium]   denyInsecure: {
[Appium]   }
[Appium] Appium REST http interface listener started on 0.0.0.0:4723
```

5.查看现在可用的手机设备

```shell
❯ adb devices
List of devices attached
127.0.0.1:62001 device
```

注意看这里的`127.0.0.1:62001`,这是一个字符串,如果是用真实手机的话,这里显示的是一串连续的字符串

6.sdk连接appium

```shell
appium -a 127.0.0.1 -p 4723 -U 127.0.0.1:62001
```

-a 就是appium启动的ip地址

-a 就是appium启动的端口

-U 就是在第五步获取的字符串`127.0.0.1:62001`,连接这台手机设备

## 5.编写脚本

安装包

```shell
pip install Appium-Python-Client
```

脚本,这里是个简单的抖音的自动点赞功能

```python
import time

from appium import webdriver

desired_caps =dict()
# 平台名称,安卓就是Android
desired_caps['platformName']='Android'
# 平台的版本
desired_caps['platformVersion']='5.1'
# 设备的名字,貌似可以随便写
desired_caps['deviceName']='Android'
# 包名
desired_caps['appPackage']='com.ss.android.ugc.aweme'
# 界面名
desired_caps['appActivity']='.splash.SplashActivity'
# 不用每次都重新安装app
desired_caps['noReset'] = True
# 输入中文
desired_caps['unicodekeyboard']=True
desired_caps['resetkeyboard']=True

driver = webdriver.Remote('http://127.0.0.1:4723/wd/hub',desired_caps)
driver.implicitly_wait(30)


while True:
    # 滑动
    print("开始滑动")
    driver.swipe(200,900,300,500,500)
    print("滑动完成,休息")
    time.sleep(5)

    # 进入头像
    driver.find_element_by_id("com.ss.android.ugc.aweme:id/en2").click()

    # 获取关注人数
    comment = False
    number = driver.find_element_by_id("com.ss.android.ugc.aweme:id/arh").text
    if number.find("w") != -1:
        print("关注人数"+str(number))
        # 关注
        print("开始点击关注")
        driver.find_element_by_id("com.ss.android.ugc.aweme:id/el4").click()
        print("开始点击完成")
        comment=True
    else:
        print("关注人数没有一万多,不操作了")
        break

    # 退到首页
    driver.find_element_by_id("com.ss.android.ugc.aweme:id/ks").click()

    # 是否要留言,关注了就留言
    if comment == True:
        # 点击评论按钮
        driver.find_element_by_id("com.ss.android.ugc.aweme:id/acv").click()
        # 点击评论输入框
        driver.find_element_by_id("com.ss.android.ugc.aweme:id/acp").click()
        # 写下评论
        driver.find_element_by_id("com.ss.android.ugc.aweme:id/acp").send_keys("太棒了")
        # 发送
        driver.find_element_by_id("com.ss.android.ugc.aweme:id/ad_").click()
        # 关闭评论窗口
        driver.find_element_by_id("com.ss.android.ugc.aweme:id/ks").click()

    time.sleep(10)
    print("一次循环完成")

driver.quit()

```

## 其它APi

### ADB

```shell
# 从电脑上安装软件的手机上
adb install ‪C:\迅雷下载\2a5b812be8277ae6f75b0fb736fab49a_72817400.apk

# 通过这个命令,看
adb shell dumpsys window windows | findstr mFocusedApp
```

### Python

```python
# 滑动滑动
driver.swipe(sx,sy,ex,edy,ms)

# 获取当前的包名和界面明
driver.current_package
driver.current_activity

# 隐式等待
driver.implicitly_wait(30)
```





